<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2022-10-24T20:32:50+02:00</updated><id>/feed.xml</id><title type="html">blank</title><subtitle>Robin Dupont personal page
</subtitle><entry><title type="html">üíæ DIY Cloud backup</title><link href="/blog/2022/data-backup-dupliciti/" rel="alternate" type="text/html" title="üíæ DIY Cloud backup" /><published>2022-10-09T17:24:00+02:00</published><updated>2022-10-09T17:24:00+02:00</updated><id>/blog/2022/data-backup-dupliciti</id><content type="html" xml:base="/blog/2022/data-backup-dupliciti/"><![CDATA[<p>Did you know that <a href="https://www.worldbackupday.com/" target="_blank">World Backup Day</a> is on the 31rst of March? Heck, did you even know there was a <strong>World Backup Day</strong>? Indeed backing up your data is important, but what to do?  Starting by having a remote copy of your most important data on services like Google Drive, Dropbox, Onedrive, etc‚Ä¶ is a good start! But what if you want to do it <strong>yourself</strong>? Maybe because you want <strong>better control over your data</strong>, or maybe because you do not want <a href="https://www.nytimes.com/2022/08/21/technology/google-surveillance-toddler-photo.html" target="_blank">Google to shut down your account because of what you have on your Google Drive</a>? Or maybe you just want to do it yourself because you can. In any case, the  general rule of thumb for backing up data is to follow the <strong>3-2-1</strong> rule:</p>
<ul>
  <li><strong>3</strong> copies of your important data</li>
  <li>on <strong>2</strong> different storage mediums</li>
  <li><strong>1</strong> of which is off-site</li>
</ul>

<p>The first two points are quite easy to satisfy. However, the last one (<strong>having a backup off-site</strong>), is a bit more tricky. You either need to be able to access a bit of storage on a friend‚Äôs NAS or set up a second NAS in your family or friend‚Äôs house. Certainly doable, but not the easiest solution since you need to maintain two separate computers, one of which is not easily accessible because it is precisely off-site.</p>

<p>Another way to back up your data off-site is to use a <strong>cloud storage provider</strong> and backup software. I chose to use <a href="https://www.backblaze.com/" target="_blank">BackBlaze</a> as the cloud provider because it is <strong>cheap and easy to use</strong>, even if you never used such services before. For the backup software, I will use <a href="https://www.duplicati.com/" target="_blank">Duplicati</a>. Duplicati is open source and allows for <strong>encrypted and compressed incremental backups</strong>. Incremental backup is an incredibly useful feature: You only backup the files that changed since the last backup. You do not need to back up all your files every time! Ah, and yes, Duplicati is compatible with BackBlaze!</p>

<h1 id="preparing-the-cloud-Ô∏è">Preparing the cloud ‚òÅÔ∏è</h1>

<h3 id="creating-my-first-bucket-">Creating my first bucket ü™£</h3>

<p>Let‚Äôs tackle the cloud part. Data are stored in a <strong>bucket</strong>, which is roughly a top-level folder that will contain all my backup data. To create my bucket I first sing up for an account on BackBlaze. I chose the <strong>EU region</strong> when creating my account because first, I am living in Europe, and then to prevent my data from being stored in the US. I then created a bucket to store my backup data in the ‚Äúbuckets‚Äù section of the ‚ÄúMy Account‚Äù page. Beware that it seems like t<strong>he name should be original among all bucket names on BackBlaze</strong>. To make sure the name was not already taken, I added <strong>4 random characters</strong> at the end of it. I set the bucket to private. It is possible to <strong>enable encryption</strong>, however, it is not necessary since my backup will already be encrypted by Duplicati before being uploaded to BackBlaze.</p>

<div class="row justify-content-sm-center">
    <div class="col-sm-5 mt-4 mt-md-0">
    <figure>

  <picture>
    <!-- Fallback to the original file -->
    <img class="img-fluid rounded z-depth-1" src="/assets/img/blog/data_bckp/account_creation.png" data-zoomable="" />

  </picture><figcaption class="caption">Region selection on BackBlaze</figcaption>

</figure>

    </div>
     <div class="col-sm-4 mt-4 mt-md-0">
    <figure>

  <picture>
    <!-- Fallback to the original file -->
    <img class="img-fluid rounded z-depth-1" src="/assets/img/blog/data_bckp/bucket-creation.png" data-zoomable="" />

  </picture><figcaption class="caption">Bucket Creation on BackBlaze</figcaption>

</figure>

    </div>
</div>

<h3 id="keys-of-the-realm-">Keys of the realm üîë</h3>
<p>To programmatically access your bucket, Duplicati needs <strong>API keys</strong> - here called Application Keys. If you have never heard of it, you can see them as <strong>passwords for applications</strong>. I generated keys just for Duplicati in the ‚ÄúApp Keys‚Äù section. I gave them a friendly name so I will know what they are used for in the future. Then I chose for which bucket they will be valid. It is possible to select all the buckets, but that is always a good practice to <strong>give API keys only the rights they need</strong>, nothing more! Then I chose <code class="language-plaintext highlighter-rouge">Read and Write</code> rights because I want to upload my backups (write), but I also want to retrieve them if needed (read). I left all the other parameters blank.</p>

<p>Once the keys are created they appear in a light blue rectangle (see picture below). I left the <strong>webpage open</strong> until I copied them in Duplicati. If you follow the same process as I do, beware: <strong>the keys only appear once</strong>!</p>

<div class="row justify-content-sm-center">
    <div class="col-sm-4 mt-4 mt-md-0">
    <figure>

  <picture>
    <!-- Fallback to the original file -->
    <img class="img-fluid rounded z-depth-1" src="/assets/img/blog/data_bckp/api-key-creation.png" data-zoomable="" />

  </picture><figcaption class="caption">Application Keys creation</figcaption>

</figure>

    </div>
    <div class="col-sm-5 mt-4 mt-md-0">
    <figure>

  <picture>
    <!-- Fallback to the original file -->
    <img class="img-fluid rounded z-depth-1" src="/assets/img/blog/data_bckp/api-key-visualization.png" data-zoomable="" />

  </picture><figcaption class="caption">Visualisation of the Application Keys</figcaption>

</figure>

    </div>
</div>

<h1 id="duplicati-in-a-container-">Duplicati in a container üê≥</h1>

<h3 id="getting-the-container-ready-">Getting the container ready üß∞</h3>

<p>Once the cloud part is done, I focused on Duplicati itself. For all the services I run at home, I use <strong>Docker</strong>. You can get Docker installation instructions <a href="https://docs.docker.com/engine/install/ubuntu/" target="_blank">here</a>. To keep things simple and readable, I like to use <strong>Docker Compose</strong>. It can be easily installed with a simple command:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt <span class="nb">install </span>docker-compose-plugin
</code></pre></div></div>
<p>This command will install docker compose V2 (more info <a href="https://www.docker.com/blog/announcing-compose-v2-general-availability/" target="_blank">here</a>). Not the V1 pip package <code class="language-plaintext highlighter-rouge">docker-compose</code> (there is a hyphen between <em>docker</em> and <em>compose</em> in this case).</p>

<p>Docker compose is a nice tool that allows <strong>configuring easily docker containers with a text file</strong>, which is always called <code class="language-plaintext highlighter-rouge">docker-compose.yaml</code>. It also provides some useful tools to <strong>recreate</strong> containers and <strong>pull</strong> new images for example.</p>

<p>I started by creating a new folder called <code class="language-plaintext highlighter-rouge">duplicati</code>, and inside this folder, I created a file called, you guessed it, <code class="language-plaintext highlighter-rouge">docker-compose.yaml</code>. Examples of <code class="language-plaintext highlighter-rouge">docker-compose</code> files are often provided on <strong>Docker Hub</strong>. It is the case for  <a href="https://hub.docker.com/r/linuxserver/duplicati" target="_blank">Duplicati</a>.  Here is the file content:</p>

<div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code>---
version: "2.1"
services:
  duplicati:
    image: lscr.io/linuxserver/duplicati:latest
    container_name: duplicati
    environment:
      - PUID=0
      - PGID=0
      - TZ=Europe/Paris
    volumes:
      - ./duplicati-config:/config
      - ./local-backups:/backups
      - &lt;path-to-data&gt;:/source
    ports:
      - 8200:8200
    restart: unless-stopped
</code></pre></div></div>
<p>As you can see, I used the <a href="https://www.linuxserver.io/" target="_blank">linuxserver.io</a> image.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">PUID</code> and <code class="language-plaintext highlighter-rouge">PGID</code> are ids for the user that will run Duplicati <strong>inside the container</strong>. Generally speaking, you want to set both of them to <code class="language-plaintext highlighter-rouge">1000</code>, which is the id of the <strong>first created user</strong>. However, I set them to <code class="language-plaintext highlighter-rouge">0</code>, because I want to access files owned by <strong>root</strong>.</li>
  <li><code class="language-plaintext highlighter-rouge">TZ</code> is simply the timezone, to make sure scheduled backups run when you expect them to!
For the volumes, the config will be stored in <code class="language-plaintext highlighter-rouge">duplicati-config</code> and local backups in <code class="language-plaintext highlighter-rouge">local-backups</code>. However since I will use BackBlaze, there should not be any backups stored there. Both folders will be inside the <code class="language-plaintext highlighter-rouge">duplicati</code> folder since I used relative paths.</li>
  <li>The path for the <code class="language-plaintext highlighter-rouge">/source</code> folder should be updated according to your needs. I map it to an external SSD where are located the files I want to backup. It might be tempting to add the flag <code class="language-plaintext highlighter-rouge">ro</code> for <code class="language-plaintext highlighter-rouge">read-only</code>, to make sure Duplicati <strong>does not alter the source files</strong> This will, however, <strong>prevent</strong> Duplicati from <strong>restoring</strong> the files in the <strong>source destination</strong>, and you will have to restore them in another folder (such as <code class="language-plaintext highlighter-rouge">./local-backups</code>).</li>
  <li>I left the port to the default value of <code class="language-plaintext highlighter-rouge">8200</code> in this example, but you can use whatever value suits your needs.</li>
</ul>

<p>Once this file was created I started the container with :</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker compose up <span class="nt">-d</span>
</code></pre></div></div>
<p>The <code class="language-plaintext highlighter-rouge">-d</code> option makes sure the container is started in a <strong>detached mode</strong>. I made sure everything was ok by running <code class="language-plaintext highlighter-rouge">docker compose logs -f</code>.</p>

<h3 id="configuration-through-the-web-interface-">Configuration through the web interface üîß</h3>

<p>To reach the web interface, I went to the IP of the computer hosting the docker container, followed by the port, so in the case of this example : <code class="language-plaintext highlighter-rouge">8200</code>.</p>

<p>The web interface is straightforward. I created a new backup. In destination, I choose specifically the <code class="language-plaintext highlighter-rouge">B2 Cloud Storage</code> option. The <strong>bucket name</strong> is the same as the one I just created : <code class="language-plaintext highlighter-rouge">data-backup-ej8c</code>. <strong>Folder path</strong> is the path inside the bucket. I simply add a directory called <code class="language-plaintext highlighter-rouge">backcups</code> at the root of the bucket. and finally I inputed the <code class="language-plaintext highlighter-rouge">keyID</code> (for <code class="language-plaintext highlighter-rouge">B2 Application ID</code>) and <code class="language-plaintext highlighter-rouge">applicationKey</code> (for <code class="language-plaintext highlighter-rouge">B2 Application Key</code>) that were generated on the Backblaze website.</p>

<div class="row justify-content-sm-center">
    <div class="col-sm-8 mt-4 mt-md-0">
    <figure>

  <picture>
    <!-- Fallback to the original file -->
    <img class="img-fluid rounded z-depth-1" src="/assets/img/blog/data_bckp/duplicati-config.png" data-zoomable="" />

  </picture><figcaption class="caption">Backup creation in Duplicati</figcaption>

</figure>

    </div>
</div>

<p>I then followed through with the configuration, by selecting my source file and also specifying the backup schedule.</p>

<p>Once the backup is done, I clicked <em>Run Now</em> to make sure the <strong>first backup</strong> was created and voil√†!</p>

<p>Browsing the files on Backblaze should now show <strong>a bunch of files</strong> all of the same sizes (except for a few with index in the name).</p>

<div class="row justify-content-sm-center">
    <div class="col-sm-8 mt-4 mt-md-0">
    <figure>

  <picture>
    <!-- Fallback to the original file -->
    <img class="img-fluid rounded z-depth-1" src="/assets/img/blog/data_bckp/backblaze-file-browsing.png" data-zoomable="" />

  </picture><figcaption class="caption">Backup creation in Duplicati</figcaption>

</figure>

    </div>
</div>

<h3 id="updating-duplicati-Ô∏è">Updating Duplicati ‚¨ÜÔ∏è</h3>

<p>Since I used Docker Compose, updating Duplicati is <strong>really simple</strong>. Once in the same folder as the <code class="language-plaintext highlighter-rouge">docker-compose.yaml</code> file, I first update the image with :</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker compose pull
</code></pre></div></div>
<p>and recreate the container with:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker compose up <span class="nt">-d</span>
</code></pre></div></div>

<h1 id="reliable-backups-Ô∏è">Reliable backups ‚òùÔ∏è</h1>
<p>Backblaze can arguably be regarded as <strong>reliable</strong>. It is to say that I will not lose files hosted there. But what if I <strong>lost the Duplicati container</strong>? Recreating the container can be achieved in a <strong>matter of minutes</strong> from a fresh <code class="language-plaintext highlighter-rouge">docker-compose.yaml</code> file. However, I will miss the backup configuration. Fortunately, it is possible to <strong>export</strong> a Duplicati <strong>backup configuration file</strong>. I exported the configuration file <strong>with the passwords</strong> (it is to say with the Backblaze API keys) and safely backed it up on another computer.</p>

<p>‚ö†Ô∏è Bear in mind that if you <strong>encrypted</strong> your backup, the <strong>recovery key will not be exported</strong> in the configuration file and you will have to back it up yourself somewhere. Maybe on your password manager?</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Did you know that World Backup Day is on the 31rst of March? Heck, did you even know there was a World Backup Day? Indeed backing up your data is important, but what to do? Starting by having a remote copy of your most important data on services like Google Drive, Dropbox, Onedrive, etc‚Ä¶ is a good start! But what if you want to do it yourself? Maybe because you want better control over your data, or maybe because you do not want Google to shut down your account because of what you have on your Google Drive? Or maybe you just want to do it yourself because you can. In any case, the general rule of thumb for backing up data is to follow the 3-2-1 rule: 3 copies of your important data on 2 different storage mediums 1 of which is off-site]]></summary></entry><entry><title type="html">üõ†Ô∏è Modding your Game Boy Advance</title><link href="/blog/2022/modding-your-game-boy-advance/" rel="alternate" type="text/html" title="üõ†Ô∏è Modding your Game Boy Advance" /><published>2022-04-05T22:15:00+02:00</published><updated>2022-04-05T22:15:00+02:00</updated><id>/blog/2022/modding-your-game-boy-advance</id><content type="html" xml:base="/blog/2022/modding-your-game-boy-advance/"><![CDATA[<p>Recently I wanted to play <em>Pok√©mon Fire Red</em> üî• on original hardware, it is to say a <strong>Game Boy Advance</strong> (GBA) and not an emulator of any kind. Since I had a GBA SP (AGS-001) as a kid, I wanted to play on a <strong>standard</strong> GBA for the sake of ‚Äúnovelty‚Äù. However, the original GBA has a <strong>reflective screen</strong>. This type of screen does not emit its <strong>own light</strong> and needs an external light source (such as the sun for example). This makes the screen notoriously <strong>difficult to see</strong> since you need to orient it in a <strong>certain angle</strong> in order to see what it is displaying. More modern screen technologies include their own source of light. The first generation of GameBoy Advance SP (AGS-001) model features a <strong>frontlit screen</strong>. This is the same principle as the old reflective screen, except that light is emitted by a small <strong>led strip</strong> at the bottom of the screen. The latest GBA SP model (AGS-101) features a modern <strong>backlit screen</strong>, where the light source comes from <strong>behind the pixels</strong>. However, this GBA SP revision is rarer that the common AGS-001 frontlit model. In order to play in the best conditions but yet with original hardware, I will mod an original GBA to make a more <strong>up-to-date handheld console</strong>.</p>

<p><br /></p>

<div class="row justify-content-sm-center">
    <div class="col-sm-5 mt-3 mt-md-0">
    <figure>

  <picture>
    <!-- Fallback to the original file -->
    <img class="img-fluid rounded z-depth-1 img-responsive full-widt" src="/assets/img/blog/gba_modding/gba_modding_1.jpg" data-zoomable="" />

  </picture><figcaption class="caption">Original GBA</figcaption>

</figure>

    </div>
    <div class="col-sm-5 mt-3 mt-md-0">
    <figure>

  <picture>
    <!-- Fallback to the original file -->
    <img class="img-fluid rounded z-depth-1 img-responsive full-widt" src="/assets/img/blog/gba_modding/gba_modding_21.jpg" data-zoomable="" />

  </picture><figcaption class="caption">Modded GBA</figcaption>

</figure>

    </div>
</div>

<h2 id="modding-a-gba">Modding a GBA</h2>

<p>As I told you, the main improvement point for the GBA is to <strong>replace the screen</strong> for a modern backlit LCD. However this is <strong>not the only thing</strong> you might want to change. Here is a list of all the parts I bought for my modding project. I ordered all my parts on <a href="https://www.retromodding.com/">Retro Moding</a>, although you can buy them on <strong>various specialized websites</strong> as well Aliexpress.</p>

<h3 id="parts">Parts</h3>
<ul>
  <li>
    <p><a href="https://www.retromodding.com/collections/game-boy-advance/products/game-boy-advance-ips-lcd">IPS LCD Screen</a>: There are various <strong>LCD mods</strong> for the GBA, such as retrofitting a AGS-101 (second GBA SP version) screen, or a <strong>DSi lower screen</strong> (this mod is often called <em>ITA</em> : DS<em>i</em> <em>t</em>o GB<em>A</em> ). However I went with the more modern FunnyPlaying IPS LCD V2, which supports <strong>brightness control</strong> provided that you solder a few wires (more on that later).</p>
  </li>
  <li>
    <p><a href="https://www.retromodding.com/collections/game-boy-advance/products/funny-playing-game-boy-advance-shells-branded">New shell</a>: I decided to buy a new shell for 3 reasons. First, because I bought a second-hand Game Boy Advance and although the shell was in pretty good condition, I vanted to have a <em>brand new shell</em> feeling. Then because the LCD screen I bought necessitates some <strong>cuts</strong> in the original shell, and I wanted to <strong>preserve it</strong>. Fortunately FunnyPlaying also provides shell <strong>specifically moulded</strong> for their LCD. And finally, because there are a lot of color to choose from. So you can build yourself a <strong>nice-looking GBA!</strong></p>
  </li>
  <li>
    <p><a href="https://www.retromodding.com/products/game-boy-advance-buttons?variant=5398357278753">New Buttons</a>: Just to match your new shell!</p>
  </li>
  <li>
    <p><a href="https://www.retromodding.com/products/funny-playing-game-boy-advance-silicone-pads?variant=41350446645404">New Silicone Pads</a>: The original silicone pads might be a bit <strong>worn out</strong> so you might want to replace them. Moreover, if you want to use a <strong>clear case</strong>, you can choose <strong>colorful</strong> silicon pads. Bear in mind that your start and select buttons will the <strong>same color</strong> as the silicone pads (since they actually are a one-piece silicone pad)!</p>
  </li>
  <li>
    <p><a href="https://www.retromodding.com/products/budget-game-boy-advance-glass-screen-lens?variant=31432753184832">New Glass Lens</a>: The FunnyPlaying IPS LCD V2 has slightly <strong>different dimensions</strong> from the old screen, so you need an <strong>appropriate lens</strong>. A glass lens will be more <strong>scratch-resistant</strong> than a plastic one, but it might <strong>shatter</strong> if dropped. Pick the one you like! There are several colors and variants as well.</p>
  </li>
  <li>
    <p><a href="https://www.retromodding.com/products/game-boy-advance-rechargeable-usb-c-battery-pack?_pos=1&amp;_sid=7e53d2891&amp;_ss=r">USB-C Rechargeable Battery</a>: The original Game Boy Advance used two AA batteries. Fortunately, you can now use a USB-C <strong>rechargeable battery pack</strong> that fits in the battery compartment. This battery pack fits in the FunnyPlaying shell without modification. If you use an original shell, you will need to <strong>trim</strong> a bit the battery compartment.</p>
  </li>
</ul>

<h3 id="building-process">Building Process</h3>

<h4 id="disassembly">Disassembly</h4>

<p>First I started by fully dissasembling the original GBA. For this step you need <strong>two</strong> screw drivers. A standard <strong>philips</strong> screw driver and a <strong>tri-wing</strong> one (this type of screw is very oftenly used by Nintendo). This is an appropriate time to <strong>clean the PCB</strong> with <strong>isopropyl alcohol</strong>, especially the golden pads located <strong>under the buttons</strong> to make sure the silicon pads make <strong>good contact</strong> with them.
<br /></p>
<div class="row justify-content-sm-center">
    <div class="col-sm mt-4 mt-md-0">
    <figure>

  <picture>
    <!-- Fallback to the original file -->
    <img class="img-fluid rounded z-depth-1" src="/assets/img/blog/gba_modding/gba_modding_9.jpg" data-zoomable="" />

  </picture><figcaption class="caption">View of all the parts</figcaption>

</figure>

    </div>
    <div class="col-sm mt-4 mt-md-0">
    <figure>

  <picture>
    <!-- Fallback to the original file -->
    <img class="img-fluid rounded z-depth-1" src="/assets/img/blog/gba_modding/gba_modding_6.jpg" data-zoomable="" />

  </picture><figcaption class="caption">GBA motherboard</figcaption>

</figure>

    </div>
</div>
<div class="row justify-content-sm-center">
    <div class="col-sm mt-4 mt-md-0">
    <figure>

  <picture>
    <!-- Fallback to the original file -->
    <img class="img-fluid rounded z-depth-1" src="/assets/img/blog/gba_modding/gba_modding_7.jpg" data-zoomable="" />

  </picture><figcaption class="caption">Original GBA</figcaption>

</figure>

    </div>
    <div class="col-sm mt-4 mt-md-0">
    <figure>

  <picture>
    <!-- Fallback to the original file -->
    <img class="img-fluid rounded z-depth-1" src="/assets/img/blog/gba_modding/gba_modding_5.jpg" data-zoomable="" />

  </picture><figcaption class="caption">Close up of the motherboard</figcaption>

</figure>

    </div>
</div>

<p>Although I did not take any pictures of this step, I advise you to <strong>test the screen</strong> at this step. Simply put the <strong>ribon cable</strong> of the new screen in the connector located at the top of the motherboard, and power up your GBA, just to confirm the screen is turning on and showing the <em>Game Boy</em> logo.</p>

<h4 id="assembly">Assembly</h4>

<p>Once I confirmed the screen was ok, I soldered the three <strong>tiny wires</strong> that came with the screen. These wires are to be soldered on the motherboard to enable screen brightness control through <code class="language-plaintext highlighter-rouge">select+L</code> or <code class="language-plaintext highlighter-rouge">select+R</code>. I found easier to solder the wires to the ribon cable first and then to solder the other ends to the appropriate locations. I used a bit of <strong>duct tape</strong> (since I did not had any kapton tape) to secure the ribon cable in place on the <strong>back of the screen</strong>. 
<br /></p>
<div class="row justify-content-sm-center">
    <div class="col-sm mt-4 mt-md-0">
    <figure>

  <picture>
    <!-- Fallback to the original file -->
    <img class="img-fluid rounded z-depth-1" src="/assets/img/blog/gba_modding/gba_modding_10.jpg" data-zoomable="" />

  </picture><figcaption class="caption">Close up of the soldered wires</figcaption>

</figure>

    </div>
    <div class="col-sm mt-4 mt-md-0">
    <figure>

  <picture>
    <!-- Fallback to the original file -->
    <img class="img-fluid rounded z-depth-1" src="/assets/img/blog/gba_modding/gba_modding_11.jpg" data-zoomable="" />

  </picture><figcaption class="caption">Close up of the motherboard</figcaption>

</figure>

    </div>
</div>

<p>I placed the screen in the case (<strong>be gentle</strong>, you do not want to break the LCD pannel) and <strong>solder</strong> the wires to the motherboard. I used the foam pad that came with the screen. I made a <strong>small inscision</strong> in the foam pad to let the wires through. Do not forget to put the <strong>buttons</strong> and the <strong>silicon pads</strong> as well !</p>

<p>Depending on your motherboard revision, there are <strong>two possible screen connector</strong>. One with <strong>32 pins</strong> and one with <strong>40 pins</strong>. Mine was 40 pins, but if you have the 32 pins variant, just <strong>bend the ribon cable</strong> to expose the correct connector on the top of the screen.</p>

<div class="row justify-content-sm-center">
    <div class="col-sm-7 mt-4 mt-md-0">
    <figure>

  <picture>
    <!-- Fallback to the original file -->
    <img class="img-fluid rounded z-depth-1" src="/assets/img/blog/gba_modding/gba_modding_12.jpg" data-zoomable="" />

  </picture><figcaption class="caption">Wires soldered to the motherboard</figcaption>

</figure>

    </div>  
</div>

<p>After that, I <strong>secured the motherboard</strong> to the front part of the shell. I then added the <strong>battery cover</strong> and the <strong>sticker</strong> for a more <em>genuine</em> look.</p>
<div class="row justify-content-sm-center">
<div class="col-sm mt-4 mt-md-0">
    <figure>

  <picture>
    <!-- Fallback to the original file -->
    <img class="img-fluid rounded z-depth-1" src="/assets/img/blog/gba_modding/gba_modding_14.jpg" data-zoomable="" />

  </picture><figcaption class="caption">With the back of the shell</figcaption>

</figure>

    </div>
<div class="col-sm mt-4 mt-md-0">
    <figure>

  <picture>
    <!-- Fallback to the original file -->
    <img class="img-fluid rounded z-depth-1" src="/assets/img/blog/gba_modding/gba_modding_19.jpg" data-zoomable="" />

  </picture><figcaption class="caption">Battery cover and sticker added</figcaption>

</figure>

    </div>
<div class="col-sm mt-4 mt-md-0">
    <figure>

  <picture>
    <!-- Fallback to the original file -->
    <img class="img-fluid rounded z-depth-1" src="/assets/img/blog/gba_modding/gba_modding_16.jpg" data-zoomable="" />

  </picture><figcaption class="caption">Ready to add the glass lens</figcaption>

</figure>

    </div>
</div>

<p>Before putting the glass lens, I made sure that there were <strong>no dust</strong> on the screen or the screen-facing side of the glass lens, since it would <strong>not be possible</strong> to clean it <strong>later</strong>. I finally removed the glass lens protection film. Here is the final result :</p>

<div class="row justify-content-sm-center">
    <div class="col-sm-8 mt-4 mt-md-0">
    <figure>

  <picture>
    <!-- Fallback to the original file -->
    <img class="img-fluid rounded z-depth-1" src="/assets/img/blog/gba_modding/gba_modding_20.jpg" data-zoomable="" />

  </picture><figcaption class="caption">With the back of the shell</figcaption>

</figure>

    </div>
</div>

<p>Now let‚Äôs beat the <strong>Pok√©mon league</strong> !</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Recently I wanted to play Pok√©mon Fire Red üî• on original hardware, it is to say a Game Boy Advance (GBA) and not an emulator of any kind. Since I had a GBA SP (AGS-001) as a kid, I wanted to play on a standard GBA for the sake of ‚Äúnovelty‚Äù. However, the original GBA has a reflective screen. This type of screen does not emit its own light and needs an external light source (such as the sun for example). This makes the screen notoriously difficult to see since you need to orient it in a certain angle in order to see what it is displaying. More modern screen technologies include their own source of light. The first generation of GameBoy Advance SP (AGS-001) model features a frontlit screen. This is the same principle as the old reflective screen, except that light is emitted by a small led strip at the bottom of the screen. The latest GBA SP model (AGS-101) features a modern backlit screen, where the light source comes from behind the pixels. However, this GBA SP revision is rarer that the common AGS-001 frontlit model. In order to play in the best conditions but yet with original hardware, I will mod an original GBA to make a more up-to-date handheld console.]]></summary></entry><entry><title type="html">üêã Custom Docker image for Ethereum mining</title><link href="/blog/2021/ethereum-mining-with-docker/" rel="alternate" type="text/html" title="üêã Custom Docker image for Ethereum mining" /><published>2021-10-21T20:56:00+02:00</published><updated>2021-10-21T20:56:00+02:00</updated><id>/blog/2021/ethereum-mining-with-docker</id><content type="html" xml:base="/blog/2021/ethereum-mining-with-docker/"><![CDATA[<h2 id="about-ethereum-and-ethereum-mining">About Ethereum and Ethereum mining</h2>

<p><strong>Ethereum</strong> is the second most popular cryptocurrency by volume on the internet. One nice thing about it is that it has been conceived to be <strong>ASICs-proof</strong>. You can <em>in theory</em>, only mine ETH on a GPU or CPU. It is to say that you could help secure the blockchain and more importantly <strong>earn a bit of ETH</strong> from your computer. No need for an expensive and <strong>noisy ASIC miner</strong> !</p>

<p>If you want to mine cryptocurrency easily, you can use premade binaries (such as <a href="https://trex-miner.com/">T-Rex miner</a>) or services (such as <a href="https://www.nicehash.com/">NiceHash</a>). However, bear in mind that most of these binaries or services take <strong>a small fee</strong>, generally around <strong>1%</strong> of your hard-earned ETH. If you would rather keep this 1% for you or use <strong>open-source software</strong>, this is possible thanks to <a href="https://github.com/ethereum-mining/ethminer">ethminer</a>!</p>

<p>Ethminer is an open-source Ethereum miner written in C++ and compatible with both AMD (through OpenCL) and Nvidia (through CUDA) GPUs. The latest release of ethminer is from <strong>july 2019</strong>, and is built against CUDA 9 at best. With <strong>CUDA 9</strong> you <strong>will not</strong> be able to run ethminer on the <strong>most recent Nvidia cards</strong> (RTX 3000 series, for example, requires at least CUDA 11.1). Therefore you will need to <strong>build ethminer yourself</strong> if you want to use recent GPUs. This is far from impossible but a bit tedious since ethminer uses Hunter to fetch some dependencies. Hunter uses Bintray, which has been <a href="https://jfrog.com/blog/into-the-sunset-bintray-jcenter-gocenter-and-chartcenter/">sunseted</a> on the 1rst of May 2021.</p>

<p>To keep this simple, the easiest way to use ethminer is to use a <strong>docker container</strong> that does all the hard work of building and running ethminer for you. If you just want to use the Docker image directly, jump to the <a href="#running">section</a> about actually running ethminer. If you want some details about how to make the <strong>Dockerfile</strong> follow through the next section!</p>

<h2 id="requirements">Requirements</h2>

<p>For this project you will need to have :</p>
<ul>
  <li>A Linux machine with at least one Nvidia GPU.</li>
  <li>Docker. It can be installed on linux with <code class="language-plaintext highlighter-rouge">curl https://get.docker.com | sh</code></li>
  <li>nvidia-docker. It can be installed on Debian based version of Linux with <code class="language-plaintext highlighter-rouge">sudo apt install nvidia-docker2</code></li>
  <li>The Nvidia drivers. It can be installed on Ubuntu with <code class="language-plaintext highlighter-rouge">sudo apt install nvidia-headless-470-server</code> if it was not already installed.</li>
</ul>

<h2 id="creating-the-dockerfile">Creating the Dockerfile</h2>

<p>First, let us create a directory to work in, I will call it <code class="language-plaintext highlighter-rouge">ethminer-docker</code>. In our folder, we will first create a script to launch ethminer. Create a file <code class="language-plaintext highlighter-rouge">mining.sh</code> and write the following script:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ethminer <span class="nt">--HWMON</span> 2 <span class="se">\ </span> 
         <span class="nt">-P</span> <span class="nv">$MINING_ADDRESS</span> <span class="se">\ </span>
         <span class="nt">--api-bind</span> 0.0.0.0:3333
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">--HWMON 2</code> Enable hardware monitoring <br />
<code class="language-plaintext highlighter-rouge">-P $MINING_ADDRESS</code> Uses an environment variable to store the pool address + wallet <br />
<code class="language-plaintext highlighter-rouge">--api-bind 0.0.0.0:3333</code> Enable the API on port 3333. There is no need to change the port, since we can expose a different port to the host with Docker.</p>

<p>Your folder structure should now look like this:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ethminer-docker
‚îî‚îÄ‚îÄ mining.sh
</code></pre></div></div>

<p>Now, in order to build our Docker container, we are going to write a file called <code class="language-plaintext highlighter-rouge">Dockerfile</code>. This file will contain all the instruction to create the docker image. The original instructions specific to ethminer can be found on the <a href="https://github.com/ethereum-mining/ethminer/blob/master/docs/BUILD.md"><code class="language-plaintext highlighter-rouge">docs/BUILD.md</code></a> file of the ethermine repo.</p>

<p>In our Dockerfile, we first start by writing the following line that allows us to use a <strong>premade image from Nvidia</strong> containing the drivers as a <strong>base image</strong>, on top of which we will install the drivers. As you can see here, our docker image will have the driver version <code class="language-plaintext highlighter-rouge">460.73.01</code>.</p>

<div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> nvidia/driver:460.73.01-ubuntu20.04</span>
</code></pre></div></div>
<p>Then we update the sources and install the necessary dependencies to build ethminer.<br />
The environment variable <code class="language-plaintext highlighter-rouge">DEBIAN_FRONTEND</code> is here to prevent <code class="language-plaintext highlighter-rouge">apt-get</code> from asking us questions since the installation process is supposed to be <strong>unattended</strong>. That is also why we add <code class="language-plaintext highlighter-rouge">-y</code> : to accept without further input from <code class="language-plaintext highlighter-rouge">apt-get</code></p>
<div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">RUN </span>apt-get update <span class="o">&amp;&amp;</span> <span class="se">\
</span>    <span class="nv">DEBIAN_FRONTEND</span><span class="o">=</span>noninteractive apt-get <span class="nb">install </span>kmod git cmake perl gcc g++ wget <span class="nt">--no-install-recommends</span> <span class="nt">-yq</span>
</code></pre></div></div>

<p>We fetch the CUDA install script, run it and finaly delete it in the same <code class="language-plaintext highlighter-rouge">RUN</code> statement. This prevents the addition of a lot of useless layer in the creation of the docker image. Here we download CUDA version <code class="language-plaintext highlighter-rouge">11.4.2</code></p>
<div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">RUN </span>wget <span class="nt">--no-check-certificate</span> https://developer.download.nvidia.com/compute/cuda/11.4.2/local_installers/cuda_11.4.2_470.57.02_linux.run <span class="o">&amp;&amp;</span> <span class="se">\
</span>    sh cuda_11.4.2_470.57.02_linux.run <span class="nt">--silent</span> <span class="nt">--toolkit</span> <span class="nt">--no-man-page</span> <span class="nt">--no-opengl-libs</span> <span class="o">&amp;&amp;</span> <span class="se">\
</span>    <span class="nb">rm </span>cuda_11.4.2_470.57.02_linux.run 
</code></pre></div></div>
<p>We change our working directory to <code class="language-plaintext highlighter-rouge">/</code>.</p>
<div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">WORKDIR</span><span class="s"> "/"</span>
</code></pre></div></div>

<p>This big one-liner is responsible for cloning, configuring, building ethminer and finaly removing the useless files. This command is quite a big chunk so I will explained it in details. I used a big one-liner once again to <strong>limit the number of layers generated</strong>.</p>
<div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">RUN </span>git clone https://github.com/ethereum-mining/ethminer.git <span class="nt">-o</span> ethminer <span class="o">&amp;&amp;</span> <span class="se">\
</span>    <span class="nb">cd</span> /ethminer <span class="o">&amp;&amp;</span> <span class="se">\
</span>    git submodule update <span class="nt">--init</span> <span class="nt">--recursive</span> <span class="o">&amp;&amp;</span> <span class="se">\
</span>    <span class="nb">mkdir </span>build <span class="o">&amp;&amp;</span> <span class="nb">cd </span>build <span class="o">&amp;&amp;</span> <span class="se">\
</span>    <span class="c"># Hack because bintray does not exists anymore</span>
    <span class="c"># see https://unix.stackexchange.com/questions/652841/boost-continually-fails-to-download-while-using-cmake-for-ethminer</span>
    sed -i '/hunter_config(Boost VERSION 1.66.0)/c\hunter_config(\n     Boost\n     VERSION 1.66.0_new_url\n     SHA1 f0b20d2d9f64041e8e7450600de0267244649766\n     URL https://boostorg.jfrog.io/artifactory/main/release/1.66.0/source/boost_1_66_0.tar.gz\ )' /ethminer/cmake/Hunter/config.cmake &amp;&amp; \
    cmake .. -DETHASHCL=OFF -DAPICORE=ON -DETHASHCUDA=ON -DBINKERN=OFF &amp;&amp; \
    cmake --build . &amp;&amp; \
    make install &amp;&amp; \
    cd / &amp;&amp; rm -rf ethminer
</code></pre></div></div>
<p>In this command, we first clone the repo on a folder called <code class="language-plaintext highlighter-rouge">ethminer</code>. We then basically follow the building instruction from the ethminer repo. But before the configuring, we use a big <code class="language-plaintext highlighter-rouge">sed</code> command to edit the <strong>Hunter configuration</strong>. This is necessary since without this modification, Hunter is going to try to fetch Boost on Bintray and <strong>fail</strong>. Downloading manually Boost is not going to work either. The <strong>hash does not correspond</strong> to the one expected by Hunter, hence this modification with <code class="language-plaintext highlighter-rouge">sed</code>. More details <a href="https://unix.stackexchange.com/questions/652841/boost-continually-fails-to-download-while-using-cmake-for-ethminer">here</a>.<br />
Once the modification of the Hunter <code class="language-plaintext highlighter-rouge">config.cmake</code> file is done, we generate the build configuration with 4 flags. <code class="language-plaintext highlighter-rouge">-DETHASHCL=OFF</code> <strong>disable OpenCL</strong>, since it is for AMD GPUs. However, ethminer can mine on both AMD and Nvidia GPUs at the same time. So if you want to mine Ethereum on such a hardware configuration, enable OpenCL with <code class="language-plaintext highlighter-rouge">-DETHASHCL=ON</code>. <code class="language-plaintext highlighter-rouge">-DAPICORE=ON</code> Enables the API (more details on that later). <code class="language-plaintext highlighter-rouge">-DETHASHCUDA=ON</code> makes sure <strong>CUDA support is enabled</strong>. And finally <code class="language-plaintext highlighter-rouge">-DBINKERN=OFF</code> prevent the installation of AMD binary kernels (once again, enable it if you want to use AMD GPUs).<br />
Once this is done, we build ethminer, then install it (so that it is in our <code class="language-plaintext highlighter-rouge">$PATH</code>). and finally <strong>delete the repo directory</strong> as we do not need any of these files anymore.\</p>

<p>Now we <strong>expose port <code class="language-plaintext highlighter-rouge">3333</code></strong> (or any other port that you want to use, but make sure that this is the same port as the one in your <code class="language-plaintext highlighter-rouge">mining.sh</code> script) to access the API. The API is a <strong>simple web page</strong> with a few statistics such as the list of the GPUs, their temperature, fan speed and hash rate. This is helpful since we can <strong>easily access all these informations</strong> without having to look at the <strong>docker logs</strong>.</p>
<div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">EXPOSE</span><span class="s"> 3333</span>
</code></pre></div></div>
<p>Example of the ethminer API :</p>

<figure>

  <picture>
    <!-- Fallback to the original file -->
    <img class="img-fluid rounded z-depth-1" src="/assets/img/blog/ethminer_api_example.png" title="Example of ethminer API" data-zoomable="" />

  </picture><figcaption class="caption">Example of ethminer API dashboard.</figcaption>

</figure>

<p>We need to copy our mining script in the <code class="language-plaintext highlighter-rouge">/</code> directory of you docker image.</p>
<div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">COPY</span><span class="s"> mining.sh .</span>
</code></pre></div></div>

<p>Finally, we have to <strong>overrive</strong> our base image entrypoint by adding a <strong>new one</strong>  which will <strong>launch our mining script</strong>!</p>
<div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">ENTRYPOINT</span><span class="s"> [ "bash", "mining.sh" ]</span>
</code></pre></div></div>

<p>The final Dockerfile is named <code class="language-plaintext highlighter-rouge">Dockerfile</code> (no extension) and contains the following :</p>
<div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> nvidia/driver:460.73.01-ubuntu20.04</span>

<span class="k">RUN </span>apt-get update <span class="o">&amp;&amp;</span> <span class="se">\
</span>    <span class="nv">DEBIAN_FRONTEND</span><span class="o">=</span>noninteractive apt-get <span class="nb">install </span>kmod git cmake perl gcc g++ wget <span class="nt">--no-install-recommends</span> <span class="nt">-yq</span>

<span class="k">RUN </span>wget <span class="nt">--no-check-certificate</span> https://developer.download.nvidia.com/compute/cuda/11.4.2/local_installers/cuda_11.4.2_470.57.02_linux.run <span class="o">&amp;&amp;</span> <span class="se">\
</span>    sh cuda_11.4.2_470.57.02_linux.run <span class="nt">--silent</span> <span class="nt">--toolkit</span> <span class="nt">--no-man-page</span> <span class="nt">--no-opengl-libs</span> <span class="o">&amp;&amp;</span> <span class="se">\
</span>    <span class="nb">rm </span>cuda_11.4.2_470.57.02_linux.run 

<span class="k">WORKDIR</span><span class="s"> "/"</span>

<span class="k">RUN </span>git clone https://github.com/ethereum-mining/ethminer.git <span class="nt">-o</span> ethminer <span class="o">&amp;&amp;</span> <span class="se">\
</span>    <span class="nb">cd</span> /ethminer <span class="o">&amp;&amp;</span> <span class="se">\
</span>    git submodule update <span class="nt">--init</span> <span class="nt">--recursive</span> <span class="o">&amp;&amp;</span> <span class="se">\
</span>    <span class="nb">mkdir </span>build <span class="o">&amp;&amp;</span> <span class="nb">cd </span>build <span class="o">&amp;&amp;</span> <span class="se">\
</span>    <span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'/hunter_config(Boost VERSION 1.66.0)/c\hunter_config(\n     Boost\n     VERSION 1.66.0_new_url\n     SHA1 f0b20d2d9f64041e8e7450600de0267244649766\n     URL https://boostorg.jfrog.io/artifactory/main/release/1.66.0/source/boost_1_66_0.tar.gz\ )'</span> /ethminer/cmake/Hunter/config.cmake <span class="o">&amp;&amp;</span> <span class="se">\
</span>    cmake .. <span class="nt">-DETHASHCL</span><span class="o">=</span>OFF <span class="nt">-DAPICORE</span><span class="o">=</span>ON <span class="nt">-DETHASHCUDA</span><span class="o">=</span>ON <span class="nt">-DBINKERN</span><span class="o">=</span>OFF <span class="o">&amp;&amp;</span> <span class="se">\
</span>    cmake <span class="nt">--build</span> <span class="nb">.</span> <span class="o">&amp;&amp;</span> <span class="se">\
</span>    make <span class="nb">install</span> <span class="o">&amp;&amp;</span> <span class="se">\
</span>    <span class="nb">cd</span> / <span class="o">&amp;&amp;</span> <span class="nb">rm</span> <span class="nt">-rf</span> ethminer

<span class="k">EXPOSE</span><span class="s"> 3333</span>

<span class="k">COPY</span><span class="s"> mining.sh .</span>

<span class="k">ENTRYPOINT</span><span class="s"> [ "bash", "mining.sh" ]</span>
</code></pre></div></div>

<p>Your folder structure should now look like this:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ethminer-docker
‚îú‚îÄ‚îÄ Dockerfile
‚îî‚îÄ‚îÄ mining.sh
</code></pre></div></div>

<h2 id="building-our-docker-image">Building our Docker image</h2>

<p>Once we have our Dockerfile, this is a rather <strong>easy step</strong>. Assuming that you are in a directory containing only your Dockerfile, run</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker build <span class="nt">-t</span> ethminer <span class="nb">.</span>
</code></pre></div></div>
<p>‚ö†Ô∏è <em>Do not forget the dot at the end of the command (it means ‚Äúthe current directory‚Äù) !</em></p>

<p>You can change <code class="language-plaintext highlighter-rouge">ethermine</code> by what you want. It is the <strong>name of your docker image</strong>. You can confirm your docker image is on your system by running <code class="language-plaintext highlighter-rouge">docker image ls</code>. This should give something like this :</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REPOSITORY               TAG                     IMAGE ID       CREATED        SIZE
ethminer                 latest                  bcf676a57879   6 hours ago    7.15GB
</code></pre></div></div>

<h2 id="running-ethminer-on-docker-">Running ethminer on docker <a name="running"></a></h2>

<p>Before running ethminer, you need to <strong>install <code class="language-plaintext highlighter-rouge">nvidia-docker</code></strong>. This is a <strong>wrapper</strong> that allows docker to <strong>access your GPUs</strong> ! To install it, run :</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt <span class="nb">install </span>nvidia-docker
</code></pre></div></div>
<p>Once this is done, you can run the container with :</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">-p</span> &lt;port&gt;:3333 <span class="nt">-d</span> <span class="nt">-e</span> <span class="nv">MINING_ADDRESS</span><span class="o">=</span>&lt;your-mining-address&gt; <span class="nt">--name</span> my_ethminer 
</code></pre></div></div>
<p>‚ö†Ô∏è <em>Replace</em> <code class="language-plaintext highlighter-rouge">&lt;port&gt;</code> <em>by the port you want to use and</em> <code class="language-plaintext highlighter-rouge">&lt;your-mining-address&gt;</code> <em>by the address of the pool, combined with your wallet. You can find more info about how to write the mining address <a href="https://github.com/ethereum-mining/ethminer/blob/master/docs/POOL_EXAMPLES_ETH.md">here</a></em></p>

<p>The <code class="language-plaintext highlighter-rouge">-p &lt;port&gt;:3333</code> option allows to <strong>acces the ethminer API</strong> on port <code class="language-plaintext highlighter-rouge">&lt;port&gt;</code> of the machine you are currently running it on. If you are happy with port 3333, you can simply use <code class="language-plaintext highlighter-rouge">-p 3333</code> instead. <code class="language-plaintext highlighter-rouge">--name my_ethminer</code> gives a <strong>friendly name</strong> to your container. The <code class="language-plaintext highlighter-rouge">-d</code> makes the docker container run in <strong>detached mode</strong>. If you want to see the logs run :</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker logs <span class="nt">-f</span> my_ethminer
</code></pre></div></div>

<p>You should see logs like this :</p>
<pre><code class="language-logs">ethminer 0.19.0
Build: linux/release/gnu

 i 16:39:15 ethminer Configured pool &lt;pool-address&gt;
 i 16:39:15 ethminer Api server listening on port 3333.
 i 16:39:15 ethminer Selected pool &lt;pool-address&gt;
 i 16:39:15 ethminer Stratum mode : Eth-Proxy compatible
 i 16:39:15 ethminer Established connection to &lt;pool-address&gt; [&lt;pool-ip&gt;]
 i 16:39:15 ethminer Spinning up miners...
cu 16:39:15 cuda-0   Using Pci Id : 04:00.0 NVIDIA GeForce RTX 3070 (Compute 8.6) Memory : 7.65 GB
cu 16:39:15 cuda-1   Using Pci Id : 05:00.0 NVIDIA GeForce GTX 1060 6GB (Compute 6.1) Memory : 7.65 GB
 i 16:39:15 ethminer Epoch : 448 Difficulty : 4.29 Gh
 i 16:39:15 ethminer Job: deaebb22‚Ä¶ block 13468527 &lt;pool-address&gt; [&lt;pool-ip&gt;]
 i 16:39:17 ethminer Job: 0ca80852‚Ä¶ block 13468527 &lt;pool-address&gt; [&lt;pool-ip&gt;]
cu 16:39:17 cuda-1   Generating DAG + Light(on GPU) : 4.57 GB
cu 16:39:17 cuda-0   Generating DAG + Light(on GPU) : 4.57 GB
 i 16:39:17 ethminer New API session from &lt;your-local-ip+port&gt;
 i 16:39:17 ethminer New API session from &lt;your-local-ip+port&gt;
 i 16:39:19 ethminer Job: e0a946a7‚Ä¶ block 13468527 &lt;pool-address&gt; [&lt;pool-ip&gt;]
 m 16:39:20 ethminer 0:00 A0 0.00 h - cu0 0.00 62C 30% 188.24W, cu1 0.00 57C 49% 51.91W
</code></pre>

<p>If it is the case, <strong>congratulation</strong>! You are now mining Ethereum on your computer thanks to Docker! There was no need to install <code class="language-plaintext highlighter-rouge">kmod</code>, <code class="language-plaintext highlighter-rouge">git</code>, <code class="language-plaintext highlighter-rouge">cmake</code>, <code class="language-plaintext highlighter-rouge">perl</code>, etc‚Ä¶ or even the CUDA Toolkit. Everything was done while building the docker image!</p>

<p>If you want to stop the container, simply run <code class="language-plaintext highlighter-rouge">docker stop my_ethminer</code> and <code class="language-plaintext highlighter-rouge">docker start my_ethminer</code> to start it back.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[About Ethereum and Ethereum mining]]></summary></entry></feed>